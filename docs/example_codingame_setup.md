# Example setup for CodinGame

We are going to setup CG Arena for generic CodinGame challenge. We would use [Cellularena](https://www.codingame.com/multiplayer/bot-programming/winter-challenge-2024) as an example.

## Configuration

We can use the default config generated by `cgarena init` for the most settings.

Let's review the game settings part:

- `[game]`
  - `min_players` is already set to **2**
  - `max_players` is already set to **2**
  - `symmetric` is already set to **true**

## Worker configuration

We would need to set `threads` based on our CPU. In my case I set to **4**.

```toml
threads = 4
```

Let's use some generic settings for the embedded worker:

```toml
cmd_play_match = "python play_game.py {SEED} {PLAYERS}"
cmd_build = "sh build.sh {DIR} {LANG}"
cmd_run = "sh run.sh {DIR} {LANG}"
```

You would also need to create the following files:
- `play_game.py`
- `build.sh`
- `run.sh`

Let's review each of them.

### `player_game.py`

Assuming you have brutaltester-compatible referee named `referee.jar` ([how to make one](making_bt_compatible_referee.md)) you can use the following script:

```python
import sys, subprocess, json, tempfile, os, re

if __name__ == '__main__':
    f, log_file = tempfile.mkstemp(prefix='log_')
    os.close(f)

    n_players = len(sys.argv) - 2
    seed = sys.argv[1]
    
    # assumes brutaltester-compatible referee.jar is placed in the same folder
    cmd = 'java --add-opens java.base/java.lang=ALL-UNNAMED -jar referee.jar' + ''.join([f' -p{i} "{sys.argv[i + 1]}"' for i in range(1, n_players+1)]) + f' -d seed={seed} -l "{log_file}"'
    task = subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    with open(log_file, 'r') as f:
        json_log = json.load(f)
    os.remove(log_file)
    p_scores = [int(json_log['scores'][str(i)]) for i in range(n_players)]
    rv = {}
    rv['ranks'] = [sum([int(p_score < p2_score) for p2_score in p_scores]) for p_score in p_scores] # assumes higher score is better
    rv['errors'] = [int(p_score < 0) for p_score in p_scores] # assumes negative score means error
    rv['attributes'] = []

    pattern = r"\[(T|P)DATA\](?:\[(\d+)\])?\s+(\w+)\s*=\s*(.+)"
    regex = re.compile(pattern, re.IGNORECASE)

    for player, key in enumerate([str(i) for i in range(n_players)]):
        for data in json_log['errors'][key]:
            if not data: continue
            for line in [line.strip() for line in data.split('\n')]:
                match = regex.match(line)
                if not match: continue

                type_tag = match.group(1).upper()  # T or P
                turn = match.group(2)             # optional number
                key = match.group(3)
                value = match.group(4)

                attribute = {
                    'name': key,
                    'player': player if type_tag == 'P' else None,
                    'turn': int(turn) if turn else None,
                    'value': value,
                }
                
                rv['attributes'].append(attribute)
                
    print(json.dumps(rv))
```

### `build.sh`

Generic version which supports multiple languages:

```sh
if [ "$2" = "c++" ]; then
  g++ -std=c++17 -x c++ "$1"/source.txt -o "$1"/a.exe
elif [ "$2" = "python" ]; then
  cp "$1"/source.txt "$1"/a.py
elif [ "$2" = "rust" ]; then
  cp "$1"/source.txt rust-workdir/src/main.rs
  cd rust-workdir
  cargo build --release
  cd ..
  mv rust-workdir/target/release/rust-workdir.exe "$1"/a.exe
else
  echo "Unsupported language '$2'" >&2
  exit 1
fi
```

### `run.sh`

Generic version which supports multiple languages:

```sh
if [ "$2" = "c++" ]; then
  ./"$1"/a.exe
elif [ "$2" = "python" ]; then
  python ./"$1"/a.py
elif [ "$2" = "rust" ]; then
  ./"$1"/a.exe
else
  echo "Unsupported language '$2'" >&2
  exit 1
fi
```

### Languages that need workspace

For languages which need project folder (e.g. Rust) you build bot the following way:

- create a single project somewhere and configure it to be the same as CG (e.g. has all the dependencies)
- inside the `build.sh` copy `source.txt` to that project folder (e.g. `main.rs` for Rust)
- build the project
- copy the executable from the project build to the bot directory

You can see this in actions in the `build.sh` and `run.sh` commands above for `"rust"` language.

The `cargo.toml` inside `rust-workdir` looks like this (this is same as CG, might be outdated):

```toml
[package]
name = "rust-workdir"
version = "0.1.0"
edition = "2018"

[dependencies]
chrono = "0.4.26"
itertools = "0.11.0"
libc = "0.2.147"
# rand is a bit of a mess, see https://www.codingame.com/forum/t/languages-update/1574/120
rand_core = "0.6.3"
rand = { version = "0.8.5", features = ["small_rng"] }
regex = "1.8.4"
time = "0.3.22"
```